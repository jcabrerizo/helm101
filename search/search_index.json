{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kubernetes, Helm and other container-ish notes","text":"<ul> <li>AWS: ECR &amp; EKS + <code>eksctl</code></li> <li>containerImages</li> <li>Kubernetes &amp; kubectl</li> <li>miscellanea</li> <li>tools</li> <li>Helm</li> </ul>"},{"location":"#training","title":"Training","text":"<ol> <li>exercises</li> <li>Official Linux Foundation training LFD 259</li> <li>dgkanatsios/CKAD-exercises repo \u2b50\ufe0f\u2b50\ufe0f\u2b50\ufe0f\u2b50\ufe0f\u2b50\ufe0f</li> </ol>"},{"location":"#todo","title":"TODO","text":"<ul> <li> <code>yq</code> notes</li> <li> <code>jsonpath</code> notes</li> <li> <code>docker</code> and <code>podman</code> commands</li> <li> <code>Dockefile</code> examples:   <pre><code>FROM docker.io/httpd:2.4\nRUN echo \"Hello, World!\" &gt; /usr/local/apache2/htdocs/index.html\n</code></pre></li> <li> Add in <code>helm repo login</code> commands examples of the repo url, as it's important</li> <li> Generate better <code>README.md</code> files for the root of each dir.</li> <li> Automate ^</li> <li> Think about making containers a sub dir and add other material to this repo?</li> </ul>"},{"location":"aws/","title":"AWS","text":"<ul> <li>ECR</li> <li>EKS add-ons</li> <li>EKS</li> </ul>"},{"location":"aws/ecr/","title":"ECR","text":""},{"location":"aws/ecr/#helm-login","title":"Helm login","text":""},{"location":"aws/ecr/#public","title":"Public","text":"<pre><code>aws ecr-public get-login-password \\\n  --region us-east-1 | helm registry login \\\n  --username AWS \\\n  --password-stdin public.ecr.aws\n</code></pre>"},{"location":"aws/ecr/#private","title":"Private","text":"<pre><code>aws ecr get-login-password \\\n  --region $AWS_REGION | helm registry login \\\n  --username AWS \\\n  --password-stdin \\\n  ${ECR_HELM_REPOSITORY%%/*}\n</code></pre>"},{"location":"aws/ecr/#docker-login","title":"Docker login","text":""},{"location":"aws/ecr/#public_1","title":"Public","text":"<pre><code>aws ecr-public get-login-password \\\n  --region us-east-1 | docker login \\\n  --username AWS \\\n  --password-stdin public.ecr.aws\n</code></pre>"},{"location":"aws/ecr/#private_1","title":"Private","text":"<pre><code>aws ecr get-login-password \\\n  --region $AWS_REGION | docker login \\\n  --username AWS \\\n  --password-stdin \\\n  ${ECR_REPO%%/*}\n</code></pre>"},{"location":"aws/ecr/#push-image-to-ecr","title":"Push image to ECR","text":"<pre><code>docker tag $DOCKER_IMAGE_ID ${ECR_REPO}/${IMAGE_NAME}:${IMAGE_NAME}\ndocker push $ECR_REPO/$IMAGE_NAME:${IMAGE_NAME}\n</code></pre>"},{"location":"aws/ecr/#push-helm-charts","title":"Push helm charts","text":"<pre><code>helm push ${CHAR_NAME}-${CHAR_VERSION}.tgz oci://${ECR_REPO}\n</code></pre>"},{"location":"aws/eks-add-ons/","title":"EKS add-ons","text":"<p>Some helm features are not supported within EKS all helm commands here are currently ran with helm version 3.8.1</p> <ul> <li>All Capabilities objects are supported, with an exception for .APIVersions *<ul> <li>i) .APIVersions is not supported for non-built in custom k8 APIs</li> </ul> </li> <li>All Release objects (except .Name and .Namespace) are not supported</li> <li>Helm hooks and the Lookup function are not supported</li> <li>All dependent charts must be located within the main helm chart (specified with repository path file://...)</li> <li>Helm chart must successfully pass Helm Lint and Helm Template with no errors</li> </ul> <pre><code>export CHART_PATH=&lt;CHART PATH&gt;\n\nexport CHART_K8N_VERSION=1.27\nexport CHART_NAMESPACE=test-template\nexport CHART_NAME=$(helm show chart $CHART_PATH |yq .name)\nexport CHART_VERSION=$(helm show chart $CHART_PATH |yq .version)\n\nhelm package $CHART_PATH\n\nhelm lint ${CHART_NAME}-${CHART_VERSION}.tgz\n\nhelm template ${CHART_NAME}-${CHART_VERSION}.tgz \\\n  --set k8version=Kubernetes-version \\\n  --kube-version ${CHART_K8N_VERSION} \\\n  --namespace ${CHART_NAMESPACE} \\\n  --no-hooks \\\n  --include-crds &gt;| ${CHART_NAME}-${CHART_VERSION}.template.yaml\n</code></pre> <p>Create manifest interacting with the cluster</p> <pre><code>export CHART_RELEASE_NAME=test-release\nhelm install \\\n  --dry-run \\\n  --debug \\\n  --create-namespace \\\n  --namespace $CHART_NAMESPACE \\\n  $CHART_RELEASE_NAME $CHART_PATH &gt;|  ${CHART_NAME}-${CHART_VERSION}.dryrun.yaml\n</code></pre>"},{"location":"aws/eks-add-ons/#list-add-ons","title":"List add-ons","text":"<p><pre><code>aws eks describe-addon-versions \\\n  --kubernetes-version 1.29 \\\n  --addon-name snyk_runtime-sensor \\\n  --query 'addons[].{MarketplaceProductUrl: marketplaceInformation.productUrl, Name: addonName, Owner: owner Publisher: publisher, Type: type}' \\\n  --output table\n</code></pre> or using <code>eksctl</code></p> <pre><code>eksctl utils describe-addon-versions --kubernetes-version 1.29 --region us-east-1\n</code></pre>"},{"location":"aws/eks/","title":"EKS","text":""},{"location":"aws/eks/#eksclt","title":"<code>eksclt</code>","text":"<p>https://eksctl.io/</p> <p>https://eksctl.io/getting-started/</p>"},{"location":"aws/eks/#commands","title":"Commands","text":"<p>WARNING</p> <p>The <code>eksctl create cluster</code> execution will overwrite the <code>~/.kube/config</code> file to configure access</p> <p>Create default cluster with:</p> <ul> <li>exciting auto-generated name</li> <li>two m5.large worker nodes</li> <li>use the official AWS EKS AMI</li> <li>us-west-2 region</li> <li>a dedicated VPC (check your quotas)</li> </ul> <pre><code>eksctl create cluster\n</code></pre> <p>For forcing a specific version on k8s:</p> <pre><code>eksctl create cluster --version=1.24\n</code></pre> <p>Listing existing clusters</p> <pre><code>aws eks list-clusters\n</code></pre> <p>Describe cluster shows endpoint and VPC and internet access exposure</p> <pre><code>aws eks describe-cluster --name $CLUSTER_NAME\n</code></pre> <p>Or for changing default behaviour a yaml config file can be used:</p> <p>medium2nodesCluster.yaml:</p> <pre><code>apiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\n\nmetadata:\n  name: cluster-1\n  region: eu-west-1\n  version: '1.27'\nnodeGroups:\n  - name: ng-1\n    instanceType: m5.large\n    desiredCapacity: 2\n    availabilityZones: [ \"eu-west-1a\", \"eu-west-1b\" ]\n</code></pre> <pre><code>eksctl create cluster -f medium2nodesCluster.yaml\n</code></pre> <p>or use manage node groups instead:</p> <pre><code>apiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\n\nmetadata:\n  name: manual-created-1-29-ng\n  region: ap-northeast-2\n  version: '1.29'\n\nmanagedNodeGroups:\n  - name: ng-1-workers-amd\n    labels: { role: workers }\n    instanceType: m5.large\n    desiredCapacity: 0\n    volumeSize: 80\n    privateNetworking: true\n  - name: ng-2-workers-arm\n    labels: { role: workers }\n    instanceType: m7g.large\n    desiredCapacity: 0\n    volumeSize: 100\n    privateNetworking: true\n</code></pre> <p>~~TODO~~: getting an error using this file, I think related with permissions:</p> <p>REASON: m5.medium doesn't exist. The error describing the AZs is not related.</p> <pre><code>2023-11-22 16:04:00 [\u2139]  eksctl version 0.164.0\n2023-11-22 16:04:00 [\u2139]  using region eu-west-1\n2023-11-22 16:04:01 [\u2139]  skipping eu-west-1a from selection because it doesn't support the following instance type(s): m5.medium\n2023-11-22 16:04:01 [\u2139]  skipping eu-west-1b from selection because it doesn't support the following instance type(s): m5.medium\n2023-11-22 16:04:01 [\u2139]  skipping eu-west-1c from selection because it doesn't support the following instance type(s): m5.medium\nError: getting availability zones: only 0 zones discovered [], at least 2 are required\n</code></pre> <p>Testing a config file using <code>--dry-run</code>:</p> <pre><code>eksctl create cluster -f 2_large_node_cluster.yaml --dry-run \n</code></pre> <p>Configure kubectl</p> <pre><code>aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME\n</code></pre>"},{"location":"containerImages/","title":"Container images","text":"<ul> <li>Working with manifests and images</li> <li>Copy multi-arch image from one registry to another</li> </ul>"},{"location":"containerImages/copyImages/","title":"Copy multi-arch image from one registry to another","text":"<pre><code>ORIGIN_REG=originalRegistry.docker.com\nTARGET_REG=targetRegistry.aws.com\nTAG_VERSION=latest\nTAG_NAME=my-image\nTARGET_TAG=$TARGET_REG/$TAG_NAME:$TAG_VERSION\nORIGIN_TAG=$ORIGIN_REG/$TAG_NAME:$TAG_VERSION\nAWS_REGION=us-east-1\n\n# Azure login\naz login\naz acr login --name $TARGET_REG\n\n# AWS login\naws ecr get-login-password \\\n  --region $AWS_REGION | docker login \\\n  --username AWS \\\n  --password-stdin \\\n  $ORIGIN_REG\n\n# login with docker in required registries\ndocker login -u $ORIGIN_USER -p ORIGIN_PASS $ORIGIN_REG\ndocker login -u $TARGET_USER -p TARGET_PASS $ORIGIN_REG\n\ndocker buildx imagetools create --tag \"$ORIGIN_TAG\" \"$TARGET_TAG\" \n</code></pre> <p>For testing:</p> <pre><code>docker manifest inspect $TARGET_TAG\ndocker pull $TARGET_TA\ndocker run -p=8080:8080 $TARGET_TAG\n</code></pre>"},{"location":"containerImages/manifest/","title":"Working with manifests and images","text":""},{"location":"containerImages/manifest/#inspect-manifest","title":"Inspect manifest","text":"<pre><code>MANIFEST=nginx\ndocker manifest inspect $MANIFEST\n</code></pre>"},{"location":"containerImages/manifest/#list-architectures-for-a-multi-arch-images","title":"List architectures for a multi-arch images","text":"<p>This fails if no <code>architecture</code> is present in the manifest</p> <pre><code>MANIFEST=nginx\ndocker manifest inspect $MANIFEST | jq 'if .manifests then .manifests | map(select(.platform.architecture != \"unknown\")) | map(.platform.architecture) else [] end'\n</code></pre>"},{"location":"exercices/","title":"Certification training exercises","text":"<ul> <li>killer.sh</li> <li>Muschko</li> <li>lfd259</li> </ul>"},{"location":"exercices/killer.sh/","title":"Notes from killer.sh exam","text":""},{"location":"exercices/killer.sh/#tips","title":"Tips:","text":"<ul> <li>Get familiar with the Kubernetes documentation and be able to use the search. Allowed links are:<ul> <li>https://kubernetes.io/docs</li> <li>https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#label</li> <li>https://kubernetes.io/blog</li> <li>https://helm.sh/docs</li> </ul> </li> <li>New interface https://itnext.io/cks-cka-ckad-changed-terminal-to-remote-desktop-157a26c1d5e</li> <li>Use Application --&gt; Accessories --&gt; Mousepad to write down notes for yourself during the exam.</li> <li>Add namespaces to stored scripts or commands</li> <li>Scripts can be executed as parameter of <code>sh</code>: <code>sh /path/script.sh</code></li> <li><code>-h</code> is faster to type than <code>--help</code> \ud83e\udd2b</li> <li>If no name is required in the command, probably it has a <code>--name</code> flag</li> <li><code>curl</code> supports a flag to set the max time in seconds <code>-m 5</code></li> </ul>"},{"location":"exercices/killer.sh/#questions-doubts","title":"Questions doubts","text":"<p>Captured during the exam</p> <ul> <li>q02: pod status --&gt; <code>k get pod...</code></li> <li>q03: job history --&gt; <code>k describe job</code></li> <li>q05: sa tokens</li> <li>q08: rollout</li> <li>q09: deployment syntax. spec.template.spec....</li> <li>q10: run curl on one line<ul> <li>deployment.namespace should be accessible</li> </ul> </li> <li>q11: podman build</li> <li>q11: podman terminal</li> <li>q15: curl deployment --&gt; get the ip using <code>k get pod -o wide</code> and curl that ip</li> <li>q18: find and fix connection problem</li> <li>q19: check port config and how to connect with</li> <li>q21: network policies, test dns access</li> <li>q22: label and annotate command</li> <li>pq1: study container spec, who owns what, probes, sa</li> </ul>"},{"location":"exercices/killer.sh/#main-failures","title":"Main failures","text":"<p>From the detailed score</p> <ul> <li>q10: wrong service name</li> <li>q13: need to create the storage class</li> <li>q14: wrong name!</li> <li>q18:</li> <li>q19:</li> <li>q20:</li> </ul>"},{"location":"exercices/killer.sh/#detailed-correction","title":"Detailed correction","text":""},{"location":"exercices/killer.sh/#pods","title":"Pods","text":"<ul> <li><code>readinessProbe</code> belong to the container</li> <li><code>resources</code> belong to the container</li> <li><code>securityContext</code> belong to the container</li> <li><code>volumeMounts</code> belong to the container BUT <code>volumes</code> and <code>persistentVolumeClaim</code> to the pod <code>.spec</code></li> </ul>"},{"location":"exercices/killer.sh/#deployments","title":"Deployments","text":"<ul> <li>Define the number of <code>replicas</code></li> <li>Require a selector</li> <li><code>.spec.template</code> is the same structure as the pod <code>.metadata</code> and <code>.spec</code> sections</li> </ul>"},{"location":"exercices/killer.sh/#services","title":"Services:","text":"<ul> <li>Redirection <code>3333:80</code> means <code>--port 3333 --target-port 80</code></li> <li><code>kubectl get ep</code> returns the endpoints</li> <li>The service plus the namespace should be DNS resolved: <code>curl my-service.namespace:$PORT</code></li> <li>Selectors need to target the pods, not the deployments</li> <li><code>nodePort</code> needs to be added when changing from ClusterIP to NodePort type, unless same port is desired</li> </ul>"},{"location":"exercices/killer.sh/#jobs","title":"Jobs","text":"<p>Keywords:</p> <ul> <li>completions (plural)</li> <li>parallelism</li> </ul>"},{"location":"exercices/killer.sh/#secrets","title":"Secrets","text":"<ul> <li><code>kubectl describe secret $SECRET</code> returns the unencoded secret value for some types, as <code>service-account-token</code>.</li> <li>Check injected secrets in pod:</li> <li><code>kubectl exec $POD_NAME -- find $PATH</code><ul> <li><code>kubectl exec $POD_NAME -- env | grep $ENVVAR_NAME</code></li> </ul> </li> </ul>"},{"location":"exercices/killer.sh/#rollout","title":"Rollout","text":"<ul> <li><code>kubectl rollout history $TYPE $NAME</code></li> <li><code>kubectl undo history $TYPE $NAME</code></li> <li><code>kubectl rollout restart deploy $NAME</code> force pods to be updated</li> </ul>"},{"location":"exercices/killer.sh/#helm","title":"Helm","text":"<ul> <li><code>helm repo update</code></li> <li><code>helm repo list</code></li> <li><code>helm upgrade $RELEASE $IMAGE</code></li> <li><code>helm rollback</code></li> <li><code>helm show values</code></li> <li><code>--set</code> does not allow <code>=</code> before the key to be defined: <code>helm install $RELEASE $CHART --set valueKey=Value</code>, instead   of <code>--set=valueKey=Value</code></li> </ul>"},{"location":"exercices/lfd259/","title":"Index","text":"<p>see in GitHub </p>"},{"location":"exercices/muschko/","title":"Certified Kubernetes Application Developer (CKAD) Study Guide","text":"<p>by Benjamin Muschko Released February 2021 Publisher(s): O'Reilly Media, Inc. ISBN: 9781492083733</p> <p>https://www.oreilly.com/library/view/certified-kubernetes-application/9781492083726/</p> <p>https://github.com/bmuschko/ckad-study-guide</p>"},{"location":"exercices/muschko/2/notes/","title":"Notes","text":"<ol> <li>for running a a command inside a pod need to use the <code>/bin/sh -c $COMMAND_AND_ARGUMENTS</code> syntax</li> </ol>"},{"location":"k8s/","title":"Kubernetes","text":"<ul> <li>configMap</li> <li>deployment</li> <li>externalSecret</li> <li>imperative</li> <li>index</li> <li>ingress</li> <li>job</li> <li>kubectl</li> <li>networkPolicy</li> <li>podDefinition</li> <li>rollout</li> <li>secret</li> <li>service</li> <li>serviceAccount</li> <li>storage</li> <li>troubleshooting</li> </ul>"},{"location":"k8s/configMap/","title":"ConfigMap","text":"<p>They must exist before the pods unless are optional</p> <p>Can be injected as environment var or volume</p> <pre><code>...\nenv:\n- name: $ENV_VAR_NAME\n  valueFrom:\n    configMapKeyRef:\n      name: $CONFIG_MAP_NAME\n      key: $CONFIG_MAP_KEY\n\n---\n...\nvolumes:\n  - name: $VOLUME_NAME\n    configMap:\n      name: $CONFIG_MAP_NAME\n</code></pre>"},{"location":"k8s/deployment/","title":"Deployments","text":"<p>Create deployment and set replica number</p> <pre><code>kubectl create deployment $DEPLOYMENT_NAME --image=$IMAGE\nkubectl scale deployment $DEPLOYMENT_NAME --replicas=2\n</code></pre> <p>Update image</p> <pre><code>kubectl set image deployment $DEPLOYMENT_NAME $CONTAINER_NAME=$IMAGE\n</code></pre> <pre><code>kubectl rollout history deployments $DEPLOYMENT_NAME\n</code></pre> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: $DEPLOYMENT_NAME\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      $LABEL: $LABEL_VAL\n  template:\n    metadata:\n      labels:\n        app: $LABEL_VAL\n    spec:\n      containers:\n      - name: server\n        image: $IMAGE\n</code></pre>"},{"location":"k8s/deployment/#scaling-deployments","title":"Scaling deployments","text":"<p>Scale also allows users to specify one or more preconditions for the scale action. If <code>\u2013-current-replicas</code> or <code>\u2013-resource-version</code> is specified, it is validated before the scale is attempted</p> <pre><code>kubectl scale $DEPLOYMENT_NAME --replicas=4\n</code></pre> <p>For other values the deployment can be edited using a text editor:</p> <pre><code>kubectl edit deployment $DEPLOYMENT_NAME\n</code></pre>"},{"location":"k8s/deployment/#rollbacks","title":"Rollbacks","text":"<p>A deployment change is stored and it can be rolled back</p> <pre><code>kubectl rollout status $DEPLOYMENT_NAME\nkubectl rollout restart $DEPLOYMENT_NAME\nkubectl rollout restart deployment --selector=$SELECTOR_KEY=$SELECTOR_VALUE\nkubectl rollout history $DEPLOYMENT_NAME\nkubectl rollout undo $DEPLOYMENT_NAME\n</code></pre>"},{"location":"k8s/externalSecret/","title":"External Secrets","text":"<p>https://external-secrets.io/</p> <p>Set AWS access creds:</p> <pre><code>kubectl create secret generic awssm-secret --from-file=./access-key --from-file=./secret-access-key -n $NAMESPACE\n</code></pre> <pre><code>AWS_REGION=&lt;replace&gt;\nCLUSTER_SECRET_STORE_NAME=&lt;replace&gt;\nEXTERNAL_SECRET_NAME=&lt;replace&gt;\nNAMESPACE=&lt;replace&gt;\nREMOTE_SECRET_KEY=&lt;replace&gt;\nREMOTE_SECRET_PROPERTY=&lt;replace&gt;\nSECRET_STORE_NAME=&lt;replace&gt;\nTARGET_K8S_SECRET_KEY=&lt;replace&gt;\nTARGET_K8S_SECRET_NAME=&lt;replace&gt;\n</code></pre> <p>Secret store example The SecretStore is namespaced and specifies how to access the external API. The SecretStore maps to exactly one instance of an external API.</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\n  name: $SECRET_STORE_NAME\n  namespace: $NAMESPACE\nspec:\n  provider:\n    aws:\n      service: SecretsManager\n      region: $AWS_REGION\n      auth:\n        secretRef:\n          accessKeyIDSecretRef:\n            name: awssm-secret\n            key: access-key\n#            namespace: $NAMESPACE # not needed as it must be in the same namespace as the `SecretStore`\n          secretAccessKeySecretRef:\n            name: awssm-secret\n            key: secret-access-key\n#            namespace: $NAMESPACE # not needed as it must be in the same namespace as the `SecretStore`\n</code></pre> <p>External secret The <code>ExternalSecret</code> describes what data should be fetched, how the data should be transformed and saved as a <code>kind: Secret</code></p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: $EXTERNAL_SECRET_NAME\n  namespace: $NAMESPACE\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: $SECRET_STORE_NAME\n    kind: SecretStore\n  target:\n    name: $TARGET_K8S_SECRET_NAME\n    creationPolicy: Owner\n  data:\n    - secretKey: $TARGET_K8S_SECRET_KEY\n      remoteRef:\n        key: $REMOTE_SECRET_KEY\n        property: $REMOTE_SECRET_PROPERTY\n#        decodingStrategy: Base64 # optional\n</code></pre> <p>Cluster secret store The <code>ClusterSecretStore</code> is a cluster scoped SecretStore that can be referenced by all <code>ExternalSecrets</code> from all namespaces. Use it to offer a central gateway to your secret backend.</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ClusterSecretStore\nmetadata:\n  name: $CLUSTER_SECRET_STORE_NAME\n  namespace: $NAMESPACE\nspec:\n  provider:\n    aws:\n      service: SecretsManager\n      region: $AWS_REGION\n      auth:\n        secretRef:\n          accessKeyIDSecretRef:\n            name: awssm-secret\n            key: access-key\n            namespace: $NAMESPACE\n          secretAccessKeySecretRef:\n            name: awssm-secret\n            key: secret-access-key\n            namespace: $NAMESPACE\n</code></pre> <p>External secret using <code>ClusterSecretStore</code> as origin</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: amp-external-secret\n  namespace: amp # add-on namespace\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: $CLUSTER_SECRET_STORE_NAME\n    kind: ClusterSecretStore\n  target:\n    name: $TARGET_K8S_SECRET_NAME\n    creationPolicy: Owner\n  data:\n    - secretKey: $TARGET_K8S_SECRET_KEY\n      remoteRef:\n        key: $REMOTE_SECRET_KEY\n        property: $REMOTE_SECRET_PROPERTY\n#        decodingStrategy: Base64 # optional\n</code></pre>"},{"location":"k8s/externalSecret/#tricks","title":"Tricks:","text":""},{"location":"k8s/externalSecret/#trigger-an-update","title":"Trigger an update","text":"<p>From the FAQ</p> <pre><code>kubectl annotate externalsecret $EXTERNAL_SECRET_NAME force-sync=$(date +%s) --overwrite -n $NAMESPACE\n</code></pre>"},{"location":"k8s/imperative/","title":"Imperative commands","text":""},{"location":"k8s/imperative/#pods","title":"Pods","text":""},{"location":"k8s/imperative/#create-pod","title":"Create pod","text":"<pre><code>kubectl run $NAME --image $IMAGE:$TAG --port $PORT --namespace $NAMESPACE \n</code></pre>"},{"location":"k8s/imperative/#from-file","title":"From file:","text":"<pre><code>kubectl create -f $MANIFEST_PATH\n</code></pre> <p>Notice the use of <code>create</code> instead of <code>run</code> and the absence of pod name as it's provided in the manifest</p>"},{"location":"k8s/imperative/#use-run-for-creating-a-yaml-manifest","title":"Use run for creating a <code>yaml</code> manifest","text":"<p>Use <code>-o yaml</code> and <code>--dry-run=client</code></p> <pre><code>kubectl run $NAME --image=$IMAGE -o yaml --dry-run=client &gt; $FILENAME.yaml\n</code></pre>"},{"location":"k8s/imperative/#executing-commands-in-containers","title":"Executing commands in Containers","text":""},{"location":"k8s/imperative/#temporal-pods-for-running-a-command","title":"Temporal pods for running a command","text":"<pre><code>kubectl run busybox --image=busybox --restart=Never --rm -it -n $NAMESPACE \\\n    [-- $COMMAND] \n</code></pre> <ul> <li><code>--rm</code>: Deletes the pod after exit</li> <li><code>-it</code>: Keeps <code>stdin</code> open and allocate TTY for the container</li> </ul> <p>If no command is provided, it opens an interactive shell.</p> <p>A common scenario is to make <code>wget</code> request; <code>--restart=Never</code> can't be omitted:</p> <pre><code>kubectl run $NODE_NAME --image=busybox -it --rm --restart=Never -- wget -O- $TARGET_ENDPOINT\n</code></pre>"},{"location":"k8s/imperative/#run-command-in-a-existing-pod","title":"Run command in a existing pod","text":"<p>Open a interactive shell</p> <pre><code>kubectl exec -it $POD_NAME -- /bin/sh\n</code></pre> <p>Run an isolated commandF</p> <pre><code>kubectl exec --stdin --tty $POD_NAME -- $COMMAND  \n</code></pre> <p>For multi-container pods, the flag <code>-c $CONTAINER_NAME</code> can be used for target an specific container within the pod</p>"},{"location":"k8s/imperative/#namespaces","title":"Namespaces","text":""},{"location":"k8s/imperative/#create-name-space","title":"Create name space","text":"<pre><code>kubectl create namespace $NAMESPACE\n</code></pre>"},{"location":"k8s/imperative/#delete-name-space","title":"Delete name space","text":"<p>It deletes the objects on the namespace too</p> <pre><code>kubectl delete namespace $NAMESPACE\n</code></pre>"},{"location":"k8s/imperative/#secrets","title":"Secrets","text":"<pre><code>kubectl create secret generic $SECRET_NAME --from-literal=${SECRET_KEY}=${SECRET_VALUE} -n $NAMESPACE\n</code></pre>"},{"location":"k8s/imperative/#annotations","title":"Annotations","text":"<p>Annotate existing resource</p> <pre><code>kubectl annotate [--overwrite] (-f $FILENAME | $TYPE $NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=$VERSION]\n</code></pre>"},{"location":"k8s/imperative/#labels","title":"Labels","text":"<p>Add label</p> <pre><code>kubectl label pod $POD_NAME $LABEL_KEY=u$LABEL_VALUE\n</code></pre> <p>Remove label; notice final <code>-</code></p> <pre><code>kubectl label pod $POD_NAME $LABEL_KEY-\n</code></pre>"},{"location":"k8s/imperative/#resource-selection","title":"Resource selection","text":"<p>Use the flag <code>-l</code> / <code>--selector</code></p> <pre><code>kubectl get $RESOURCE_TYPE -l $LABEL_NAME_1=$LABEL_VALUE -l '$LABEL_NAME_2 in ($VALUE_1, $OR_VALUE_2)' --show-labels\n</code></pre>"},{"location":"k8s/ingress/","title":"Ingress resources","text":"<p>List</p> <pre><code>kubectl get ingress \n</code></pre> <p>Test nginx cafe demo</p> <pre><code>export IC_HTTPS_PORT=443\nexport IC_IP=127.0.0.1\ncurl --resolve cafe.example.com:$IC_HTTPS_PORT:$IC_IP https://cafe.example.com:$IC_HTTPS_PORT/coffee --insecure\n</code></pre> <p>Test web ingress https</p> <pre><code>export IC_IP=127.0.0.1\nexport IC_HTTPS_PORT=443\nexport IC_HTTP_PORT=80\ncurl --resolve www.example.com:$IC_HTTPS_PORT:$IC_IP https://www.example.com:$IC_HTTPS_PORT/app --insecure\ncurl --resolve www.example.com:$IC_HTTP_PORT:$IC_IP http://www.example.com:$IC_HTTP_PORT/app\n</code></pre>"},{"location":"k8s/job/","title":"Job","text":"<p>https://kubernetes.io/docs/concepts/workloads/controllers/job/</p> <p>The use of <code>Jobs</code> and <code>CronJobs</code> can further assist with implementing decoupled and transient microservices.</p> <p>There are three parameters we can use to affect how the job runs:</p> <ul> <li>backoffLimit</li> <li>completions</li> <li>parallelism</li> </ul> <pre><code>apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: google-ping-every-two-min\nspec:\n  schedule: \"*/2 * * * *\"\n  successfulJobsHistoryLimit: 7\n  concurrencyPolicy: Forbid\n  failedJobsHistoryLimit: 7\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: google-ping\n            image: busybox\n            command:\n            - /bin/sh\n            - -c\n            - curl google.com \n          restartPolicy: OnFailure\n</code></pre> <p>If <code>activeDeadlineSeconds</code> is reached, details of the job shows it</p> <pre><code>...\nstatus:\n  conditions:\n  - lastProbeTime: \"2024-03-07T07:28:35Z\"\n    lastTransitionTime: \"2024-03-07T07:28:35Z\"\n    message: Job was active longer than specified deadline\n    reason: DeadlineExceeded\n    status: \"True\"\n...\n</code></pre>"},{"location":"k8s/kubectl/","title":"<code>kubectl</code> command","text":""},{"location":"k8s/kubectl/#docs","title":"Docs","text":"<ul> <li>https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands</li> <li>https://kubernetes.io/docs/reference/kubectl/quick-reference/</li> </ul>"},{"location":"k8s/kubectl/#install-kubectl","title":"Install <code>kubectl</code>","text":"<p>https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/</p>"},{"location":"k8s/kubectl/#help","title":"Help","text":"<p>This command describes the fields associated with each supported API resource</p> <pre><code>kubectl explain $RESOURCE_NAME\n</code></pre> <p>Adding the <code>`--recursive</code> flag shows the a yaml example with all its fields</p>"},{"location":"k8s/kubectl/#pod","title":"Pod","text":"<p>Get all pods</p> <pre><code>kubectl get pods -A\n</code></pre> <p>Describe pod</p> <pre><code>kubectl describe pod $POD_NAME\n</code></pre> <p>Delete pod</p> <pre><code>kubectl delete pod $POD_NAME\n</code></pre> <p>or by referencing the manifest</p> <pre><code>kubectl delete pod -f $MANIFEST.yaml\n</code></pre> <p>Force delete:</p> <pre><code>kubectl delete pod $POD_NAME --grace-period=0 --force\n</code></pre>"},{"location":"k8s/kubectl/#pod-logs","title":"Pod logs","text":"<pre><code>kubectl logs $POD_NAME\n</code></pre> <p>To look for errors in the logs of the previous pod that crashed:</p> <pre><code>kubectl logs --previous $POD_NAME\n</code></pre> <p>Logs by container inside a pod</p> <pre><code>kubectl logs $POD_NAME -c $CONTAINER_NAME\n</code></pre> <p>Events</p> <pre><code>kubectl get events -n $NAMESPACE\n</code></pre> <p>The flag <code>-f</code> (<code>--follow</code>)    Specify if the logs should be streamed.</p>"},{"location":"k8s/kubectl/#manage-context","title":"Manage context","text":"<p>List existing context</p> <pre><code>kubectl config get-contexts\n</code></pre> <p>Select context</p> <pre><code>kubectl config use-context $CONTEXT_NAME\n</code></pre> <p>Set context namespace</p> <pre><code>kubectl config set-context --current --namespace=$NAMESPACE\n</code></pre> <p>or for other context:</p> <pre><code>kubectl config set-context $CONTEXT_NAME --namespace=$NAMESPACE\n</code></pre> <p>It shows the current one and the default namespace for each one</p> <pre><code>CURRENT   NAME              CLUSTER            AUTHINFO         NAMESPACE\n*         docker-desktop    docker-desktop     docker-desktop   $CONTEXT_NAME\n          microk8s          microk8s-cluster   admin\n</code></pre> <p>for unset use <code>--namespace=''</code></p> <p>List supported API resources and abbreviations on the server</p> <pre><code>kubectl api-resources -o wide\n</code></pre> <p>List resources within a helm release:</p> <pre><code>kubectl api-resources --verbs=list -o name | xargs -n 1 kubectl get --show-kind -l app.kubernetes.io/instance=${$RELEASE_NAME} --ignore-not-found -o name\n</code></pre>"},{"location":"k8s/kubectl/#verbosity","title":"Verbosity","text":"<p>Kubectl verbosity is controlled with the <code>-v</code> or <code>--v</code> flags followed by an integer representing the log level</p> <ul> <li><code>--v=0</code>: Generally useful for this to always be visible to a cluster operator.</li> <li><code>--v=1</code>: A reasonable default log level if you don't want verbosity.</li> <li><code>--v=2</code>: Useful steady state information about the service and important log messages that may correlate to   significant changes in the system. Default</li> <li><code>--v=3</code>: Extended information about changes.</li> <li><code>--v=4</code>: Debug level verbosity.</li> <li><code>--v=5</code>: Trace level verbosity.</li> <li><code>--v=6</code>: Display requested resources.</li> <li><code>--v=7</code>: Display HTTP request headers.</li> <li><code>--v=8</code>: Display HTTP request contents.</li> <li><code>--v=9</code>: Display HTTP request contents without truncation of contents.</li> </ul>"},{"location":"k8s/networkPolicy/","title":"Network policy","text":"<p>The pods filtered by the selector will be affected</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: $POLICY_NAME\nspec:\n  podSelector:\n    matchLabels:\n      $AFFECTED_LABEL_NAME: $AFFECTED_LABEL_VALUE\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n            $TARGET_LABEL_NAME: $TARGET_LABEL_VALUE\n        - ipBlock:\n            ...\n        - namespaceSelector:\n            ...\n</code></pre> <p>The empty braces will match all Pods not selected by other NetworkPolicy and will not allow ingress traffic. Egress traffic would be unaffected by this policy.</p> <p>Default deny all ingress traffic</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\u200b\n</code></pre> <p>Other default policies: https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-policies</p>"},{"location":"k8s/podDefinition/","title":"Pod definition","text":""},{"location":"k8s/podDefinition/#pod-resource-limits","title":"Pod resource limits","text":"<ul> <li>Cpu: Exceeding the limits throttle the container or the pod</li> <li>Memory: Exceeding can't be done, but requesting more force the pod to be evicted from the node</li> <li>Ephemeral storage: the scheduler selects a node with enough space for all the containers of a pod. The pod can be   evicted if limit is reached</li> </ul>"},{"location":"k8s/podDefinition/#multi-container-pods","title":"Multi-container pods","text":""},{"location":"k8s/podDefinition/#initcontainers","title":"initContainers","text":"<p>The use of an initContainer allows one or more containers to run only if one or more previous containers run and exit successfully</p>"},{"location":"k8s/podDefinition/#simple-pod-with-initializer","title":"Simple pod with initializer","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  creationTimestamp: null\n  labels:\n    run: composed\n  name: composed\nspec:\n  containers:\n  - image: nginx\n    name: complex-pod\n    ports:\n    - containerPort: 80\n  initContainers:\n    - name: initializer \n      image: busybox\n      command: ['/bin/sh', '-c', 'wget -O- google.com']\n  dnsPolicy: ClusterFirst\n  restartPolicy: Never\n</code></pre>"},{"location":"k8s/podDefinition/#ambassador","title":"Ambassador","text":"<p>This type of secondary container would be used to communicate with outside resources</p>"},{"location":"k8s/podDefinition/#adapter","title":"Adapter","text":"<p>This type of secondary container is useful to modify the data generated by the primary containe</p>"},{"location":"k8s/podDefinition/#sidecar","title":"Sidecar","text":"<p>A sidecar is a secondary container which helps or provides a service not found in the primary application.</p> <p>Check the logs:</p> <pre><code>POD_NAME=composed\nINIT_CONTAINER_NAME=initializer\nkubectl logs --previous $POD_NAME\nkubectl logs $POD_NAME -c $INIT_CONTAINER_NAME\n</code></pre>"},{"location":"k8s/podDefinition/#probes","title":"Probes","text":"<ul> <li><code>readinessProbe</code></li> <li><code>livenessProbe</code></li> <li><code>startupProbe</code></li> </ul> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  creationTimestamp: null\n  labels:\n    run: web-server\n  name: web-server\nspec:\n  containers:\n  - image: nginx\n    name: web-server\n    ports:\n    - containerPort: 80\n      name: web\n    startupProbe:\n      httpGet:\n        path: /\n        port: web\n    readinessProbe:\n      exec:\n        command:\n          - sh\n          - -c\n          - cat /tmp/ready\n      initialDelaySeconds: 5\n      periodSeconds: 10\n    livenessProbe:\n      httpGet:\n        path: /\n        port: web\n      periodSeconds: 30\n      initialDelaySeconds: 10\n  dnsPolicy: ClusterFirst\n  restartPolicy: Always\nstatus: {}\n</code></pre>"},{"location":"k8s/podDefinition/#security-context","title":"Security context","text":"<p>https://kubernetes.io/docs/tasks/configure-pod-container/security-context/</p> <p>Prevent <code>root</code> execution</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  securityContext:\n    runAsNonRoot: true\n  containers:\n  - image: nginx\n    name: nginx\n</code></pre> <p>It could fail if the image tries to run as <code>root</code></p>"},{"location":"k8s/rollout/","title":"Rollout","text":"<p>It applies to multiple resources, including <code>deployment</code>, <code>daemonset</code> and <code>statefulset</code></p> <p>The flag <code>--dry-run</code> shows the template to be applied.</p>"},{"location":"k8s/rollout/#rollback-to-the-previous-deployment","title":"Rollback to the previous deployment","text":"<pre><code>kubectl rollout undo $NAME\n</code></pre>"},{"location":"k8s/rollout/#show-history","title":"Show history","text":"<pre><code>kubectl rollout history deployment $NAME --revision=$REVISION\n</code></pre>"},{"location":"k8s/secret/","title":"Secret","text":"<p>By default, secret are <code>base64</code> encoded, but real encryption can be configured.</p> <pre><code>kubectl create secret generic $SECRET_NAME --from-literal=$SECRET_KEY=$SECRET_VALUE\n\nkubectl get secrets\n# NAME          TYPE     DATA   AGE\n# test          Opaque   1      29m\n# $SECRET_NAME  Opaque   1      30m\n\nkubectl get secret $SECRET_NAME\n# apiVersion: v1\n# kind: Secret\n# metadata:\n#   name: $SECRET_NAME\n# data:\n#   $SECRET_KEY: $SECRET_VALUE\n</code></pre> <p>[!NOTE]\\ Example notice the secret value is passed plain, but stored as <code>base64</code></p> <pre><code>kubectl create secret generic test --from-literal=secretName=secretValue\n# kubectl get secret test -o=yaml \n# apiVersion: v1\n# data:\n#   secretName: c2VjcmV0VmFsdWU=\n# kind: Secret\n# metadata:\n#   creationTimestamp: \"2024-03-09T11:35:02Z\"\n#   name: test\n#   namespace: default\n#   resourceVersion: \"122029\"\n#   uid: c40ae44d-fc1f-4668-a451-f51628f1a187\n# type: Opaque\n\nsecret=$(kubectl get secret test -o=jsonpath='{.data.secretName}')  \n# $secret=c2VjcmV0VmFsdWU= \n\nbase64 -d &lt;&lt;&lt; $secret\n# secretValue%\n</code></pre> <p>Secrets can be injected from environment variables into a container:</p> <pre><code>...\nspec:\n    containers:\n    - image: busybox\n      name: busybox\n      env:\n      - name: $SECRET_NAME # Env var name\n        valueFrom:\n          secretKeyRef:\n            name: $SECRET_NAME\n            key: $SECRET_KEY\n</code></pre> <p>Or mounted as volumes</p> <pre><code>spec:\n    containers:\n    - image: busybox\n      name: busybox\n      command:\n        - sleep\n        - \"3600\"\n      volumeMounts:\n      - mountPath: $VOLUME_PATH\n        name: $VOLUME_NAME\n    volumes:\n    - name: $VOLUME_NAME\n      secret:\n        secretName: $SECRET_NAME\n</code></pre> <pre><code>kubectl exec -ty busybox -- cat $VOLUME_PATH/$SECRET_KEY\n# $SECRET_VALUE\n</code></pre>"},{"location":"k8s/service/","title":"Services","text":""},{"location":"k8s/service/#exposure","title":"Exposure","text":"<p>Expose a resource as a new Kubernetes service.</p> <p>Having labels in the pods is required to use <code>expose</code></p> <pre><code>kubectl expose -f $FILENAME\n</code></pre> <pre><code>kubectl expose deployment/$DEPLOYMENT --port=$PORT --type=[NodePort | ClusterIp | LoadBalancer | ExternalName]\nkubectl get svc\n# NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE \n# kubernetes   10.0.0.1     &lt;none&gt;        443/TCP        18h\n# nginx        10.0.0.112   &lt;none&gt;        80:31230/TCP   5s\n</code></pre>"},{"location":"k8s/service/#ingress-controller","title":"Ingress Controller","text":"<p>Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: minimal-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  ingressClassName: nginx-example\n  rules:\n    - http:\n        paths:\n          - path: /path\n            pathType: Prefix\n            backend:\n              service:\n                name: $SERVICE_NAME\n                port:\n                  number: 80\n</code></pre>"},{"location":"k8s/service/#port-configuration","title":"Port configuration","text":"<ul> <li><code>port</code> exposes the Kubernetes service on the specified port within the cluster. Other pods within the cluster can   communicate with this server on the specified port.</li> <li><code>targetPort</code> is the port on which the service will send requests to, that your pod will be listening on. Your   application in the container will need to be listening on this port also.</li> <li><code>nodePort</code> exposes a service externally to the cluster by means of the target nodes IP address and the NodePort.</li> </ul>"},{"location":"k8s/service/#service-types","title":"Service types","text":""},{"location":"k8s/service/#clusterip","title":"ClusterIP","text":"<p>The <code>clusterIP</code> service type is the default, and only provides access internally withing the cluster (except if manually creating an external endpoint). The range of <code>clusterIP</code> used is defined via an API server startup option.</p> <p>The <code>kubectl proxy</code> command creates a local service to access a ClusterIP. This can be useful for troubleshooting or development work.</p> <pre><code>kubectl proxy\n</code></pre>"},{"location":"k8s/service/#nodeport","title":"NodePort","text":"<p>The <code>nodePort</code> type is great for debugging, or when a static IP address is necessary, such as opening a particular address through a firewall. The NodePort range is defined in the cluster configuration.</p> <p>The NodePort is accessible via calls to <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>.</p>"},{"location":"k8s/service/#loadbalancer","title":"LoadBalancer","text":"<p>The <code>loadBalancer</code> service was created to pass requests to a cloud provider like GKE or AWS. Private cloud solutions also may implement this service type if there is a cloud provider plugin, such as with CloudStack and OpenStack. Even without a cloud provider, the address is made available to public traffic, and packets are spread among the Pods in the deployment automatically.</p>"},{"location":"k8s/service/#externalname","title":"ExternalName","text":"<p>A newer service is <code>externalName</code>, which is a bit different. It has no selectors, nor does it define ports or endpoints. It allows the return of an alias to an external service. The redirection happens at the DNS level, not via a proxy or forward. This object can be useful for services not yet brought into the Kubernetes cluster. A simple change of the type in the future would redirect traffic to the internal objects. As CoreDNS has become more stable, this service is not used as much.</p>"},{"location":"k8s/serviceAccount/","title":"Service accounts","text":""},{"location":"k8s/serviceAccount/#service-account-example","title":"Service account example","text":"<pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: $SA_NAME\n</code></pre>"},{"location":"k8s/serviceAccount/#cluster-role","title":"Cluster role","text":"<p>Example that limit access only to get and list <code>secrets</code></p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: $ROLE_NAME\nrules:\n  - apiGroups:\n    - \"\"\n    resources:\n      - secrets\n    verbs:\n     - get\n     - list\n</code></pre>"},{"location":"k8s/serviceAccount/#role-binding","title":"Role binding","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: $BINDING_NAME\nsubjects:\n  - kind: ServiceAccount\n  name: $SA_NAME\nroleRef:\n  kind: ClusterRole\n  name: $ROLE_NAME\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"k8s/storage/","title":"Storage","text":""},{"location":"k8s/storage/#list-storage-resources","title":"List storage resources","text":"<pre><code>kubectl get pv, pvc, sc\n</code></pre> <p>Three modes:</p> <ul> <li>RWO: Read write once</li> <li>ROX read only many</li> <li>RWX read write many</li> </ul> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n    name: busybox\nspec:\n    containers:\n    - name: cont_one\n      image: busybox\n      volumeMounts:\n        - mountPath: /alphadir\n          name: sharevol\n    - name: cont_tow\n      image: busybox\n      volumeMounts:\n        - mountPath: /betadir\n          name: sharevol\n    volumes:\n    - name: sharevol\n      emptyDir: {}\n</code></pre>"},{"location":"k8s/storage/#emptydir-and-hostpath","title":"emptyDir and hostPath","text":"<p><code>emptyDir</code> and <code>hostPath</code> volumes are easy to use. As mentioned, emptyDir is an empty directory that gets erased when the Pod dies, but is recreated when the container restarts.</p> <p>The <code>hostPath</code> volume mounts a resource from the host node filesystem. The resource could be a directory, file socket, character, or block device. These resources must already exist on the host to be used.</p> <p>There are two types, <code>DirectoryOrCreate</code> and <code>FileOrCreate</code>, which create the resources on the host, and use them if they don't already exist.</p>"},{"location":"k8s/storage/#persistentvolume-and-persistentvolumeclaim","title":"PersistentVolume and PersistentVolumeClaim","text":"<p>A <code>PersistentVolume</code> (<code>PV</code>) is a storage abstraction used to retain data longer than the Pod using it.</p> <p>Pods define a volume of type <code>PersistentVolumeClaim</code> (<code>PVC</code>) with various parameters for size and possibly the type of backend storage known as its <code>StorageClass</code>.</p> <p>Persistent volumes are cluster-scoped, but persistent volume claims are namespace-scoped</p> <pre><code>kind: PersistentVolume\napiVersion: v1\nmetadata:\n    name: 10Gpv01\n    labels:\n      type: local\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: \"/somepath/data01\"\n</code></pre> <pre><code>kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: $CLAIM_NAME\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 8GI\n</code></pre> <p>In the pod:</p> <pre><code>...\nspec:\n    volumes:\n        - name: test-volume\n          persistentVolumeClaim:\n                claimName: $CLAIM_NAME\n</code></pre>"},{"location":"k8s/storage/#dynamic-provisioning","title":"Dynamic provisioning","text":"<p>The StorageClass API resource allows an administrator to define a persistent volume provisioner of a certain type, passing storage-specific parameters.</p> <p>With a StorageClass created, a user can request a claim, which the API Server fills via auto-provisioning</p> <pre><code>apiVersion: storage.k8s.io/v1        \nkind: StorageClass\nmetadata:\n  name: $SC_NAME\nprovisioner: kubernetes.io/gce-pd # for Google Compute Engine\nparameters:\n  type: pd-ssd\n</code></pre>"},{"location":"k8s/troubleshooting/","title":"Troubleshooting","text":"<p>[!NOTE]\\ Create a pod and ssh in to have access to clusterIP deployments</p> <pre><code>kubectl create deployment troubleshoot --image=busybox\nkubectl exec -ti troubleshoot- -- /bin/sh\n</code></pre>"},{"location":"k8s/troubleshooting/#is-the-pod-running","title":"Is the pod running?","text":"<pre><code>kubectl describe pods $POD_NAME\nkubectl logs $POD_NAME \n</code></pre>"},{"location":"miscellanea/","title":"Miscellanea","text":"<ul> <li>Useful alias</li> <li>Kubernetes distributions</li> <li>Miscellanea</li> </ul>"},{"location":"miscellanea/alias/","title":"Useful alias","text":"<pre><code>alias k='kubectl'\nalias kkill='kubectl delete --grace-period=0 --force'\nalias ksetc='kubectl config set-context --current --namespace '\n</code></pre>"},{"location":"miscellanea/alias/#partial-commands","title":"Partial commands:","text":"<pre><code>export do=\"--dry-run=client -o yaml\"\nexport now=\"--force --grace-period 0\"\n\nkubectl run $NAME --image=$IMAGE $do\nkubectl delete pod $NAME $now\n</code></pre>"},{"location":"miscellanea/distributions/","title":"Kubernetes distributions","text":""},{"location":"miscellanea/distributions/#docker-desktop","title":"Docker desktop","text":"<p>https://www.docker.com/products/docker-desktop/</p>"},{"location":"miscellanea/distributions/#microk8s","title":"MicroK8s","text":"<p>https://microk8s.io/</p>"},{"location":"miscellanea/distributions/#install-microk8s","title":"Install MicroK8s","text":"<pre><code>sudo snap install microk8s --classic --channel=1.28\n</code></pre> <p>Needing to run <code>newgrp microk8s</code> for load the rights</p>"},{"location":"miscellanea/distributions/#config-kubeclt","title":"Config <code>kubeclt</code>","text":"<pre><code>microk8s config &gt; ~/.kube/config\n</code></pre>"},{"location":"miscellanea/miscellanea/","title":"Miscellanea","text":""},{"location":"miscellanea/miscellanea/#util-commands-scripts","title":"Util commands &amp; scripts","text":""},{"location":"miscellanea/miscellanea/#wget","title":"wget","text":"<p>Redirect response to stdout using flag <code>-O-</code></p> <pre><code>wget 10.1.0.15 -O-\n# Connecting to 10.1.0.150 (10.1.0.150:80)\n# writing to stdout\n# &lt;!DOCTYPE html&gt;\n# &lt;html&gt;\n# &lt;head&gt;\n# ...\n</code></pre>"},{"location":"miscellanea/miscellanea/#download-a-file-with-curl","title":"Download a file with curl","text":"<pre><code>curl -fsSL -o $OUTPUT_FILE_NAME $URL\n</code></pre>"},{"location":"miscellanea/miscellanea/#find-hooks","title":"Find hooks","text":"<pre><code>grep -Ril 'helm.sh/hook' | while read -r line ; do\n    echo \"Hook found in $line\"\n    sed -n '2p' $line   \ndone\n</code></pre>"},{"location":"miscellanea/miscellanea/#execute-command-in-a-set-of-pods","title":"Execute command in a set of pods","text":"<pre><code>for name in $(kubectl get pods --selector=app=appName --output name); \\\n    do kubectl exec $name -- touch /tmp/healthy; done\n</code></pre>"},{"location":"miscellanea/miscellanea/#copy-files-tofrom-the-pod","title":"Copy files to/from the pod","text":"<pre><code>kubectl cp $POD_NAME:$REMOTE_PATH $LOCAL_PATH\n</code></pre>"},{"location":"tools/","title":"Tools","text":"<ul> <li>helm</li> <li>jq</li> <li>vim</li> </ul>"},{"location":"tools/helm/","title":"Helm","text":"<p>Helm learning notes and POCs</p>"},{"location":"tools/helm/#links","title":"Links","text":"<ul> <li>Play ground: https://helm-playground.com/</li> <li>Template function list</li> </ul>"},{"location":"tools/helm/#resources","title":"Resources","text":"<p>https://www.youtube.com/watch?v=DQk8HOVlumI&amp;t=741s</p>"},{"location":"tools/helm/#setup-environment","title":"Setup environment","text":""},{"location":"tools/helm/#install-helm","title":"Install Helm","text":"<p>https://helm.sh/docs/intro/install/ https://github.com/helm/helm/releases/tag/v3.8.1</p>"},{"location":"tools/helm/#helm-101","title":"Helm 101","text":""},{"location":"tools/helm/#login-on-repo","title":"Login on repo","text":"<p>See ECR login</p>"},{"location":"tools/helm/#create-the-charm","title":"Create the charm","text":"<pre><code>helm create helloworld\n</code></pre> <pre><code>\u2514\u2500\u2500 helloworld\n \u251c\u2500\u2500 charts\n \u251c\u2500\u2500 Chart.yaml\n \u251c\u2500\u2500 templates\n \u2502   \u251c\u2500\u2500 deployment.yaml\n \u2502   \u251c\u2500\u2500 _helpers.tpl\n \u2502   \u251c\u2500\u2500 hpa.yaml\n \u2502   \u251c\u2500\u2500 ingress.yaml\n \u2502   \u251c\u2500\u2500 NOTES.txt\n \u2502   \u251c\u2500\u2500 serviceaccount.yaml\n \u2502   \u251c\u2500\u2500 service.yaml\n \u2502   \u2514\u2500\u2500 tests\n \u2502       \u2514\u2500\u2500 test-connection.yaml\n \u2514\u2500\u2500 values.yaml\n</code></pre>"},{"location":"tools/helm/#create-release","title":"Create release","text":"<pre><code>helm install releaseName helloworld\n</code></pre> <pre><code>helm list -a\n</code></pre> <pre><code>WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/juan/.kube/config\nWARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/juan/.kube/config\nNAME    NAMESPACE    REVISION    UPDATED                              STATUS   CHART        APP VERSION\nhelloworld    default   1     2023-11-12 18:17:39.662551547 +0000 UTC    deployed    helloworld-0.1.01.16.0\n</code></pre> <pre><code>kubectl get service\n</code></pre> <pre><code>NAME      TYPE     CLUSTER-IP    EXTERNAL-IP   PORT(S)     AGE\nkubernetes   ClusterIP   10.152.183.1  &lt;none&gt;     443/TCP     69m\nhelloworld   NodePort 10.152.183.123   &lt;none&gt;     80:30325/TCP   11m\n</code></pre> <p>Validate deployment, notice the port</p> <pre><code>curl http://localhost:30325\n</code></pre>"},{"location":"tools/helm/#helm-commands","title":"Helm commands","text":"<p>List all</p> <pre><code>helm list -a\n</code></pre> <p>or only with <code>kubctl</code></p> <pre><code>kubectl api-resources --verbs=list -o name | xargs -n 1 kubectl get --show-kind -l app.kubernetes.io/instance=$RELEASE_NAME --ignore-not-found -o name\n</code></pre> <p>Uninstall release</p> <pre><code>helm uninstall $RELEASE_NAME\n</code></pre> <p>Get release notes of a</p> <pre><code>helm get notes $RELEASE_NAME\n</code></pre> <p>Upgrade release, after modifying the chart code</p> <pre><code>helm upgrade example $HELM_DIR\nhelm upgrade myrelease repo/foo --set=image.tag=1.2.2\n</code></pre> <p>List release story</p> <pre><code>helm history $RELEASE_NAME\n</code></pre>"},{"location":"tools/helm/#validating-helm-chart","title":"Validating helm chart","text":"<p>Interaction with the actual k8s cluster</p> <pre><code>helm install releaseName \u2013-debug -\u2013dry-run $HELM_DIR\n</code></pre> <p>Validating only the YAMLs</p> <pre><code>helm template\n</code></pre> <p>Run linter</p> <pre><code>helm lint\n</code></pre> <p>Show helm environment variables</p> <pre><code>helm env\n</code></pre>"},{"location":"tools/jq/","title":"JQ","text":"<p>https://jqlang.github.io/jq/</p> <p>Playground</p> <p>Another playground</p> <pre><code>Usage: jq [options] &lt;jq filter&gt; [file...]\n jq [options] --args &lt;jq filter&gt; [strings...]\n jq [options] --jsonargs &lt;jq filter&gt; [JSON_TEXTS...]\n</code></pre> <p>filter must be escaped in quotes</p> <p>The simplest filter is <code>.</code> that represents the full input</p>"},{"location":"tools/jq/#flags","title":"Flags","text":"<ul> <li><code>-c</code>: compact output</li> <li><code>-r</code>: raw output</li> </ul> <pre><code>EXAMPLE='{\"field\":{\"childField\":\"value\"}}'\njq '.field' &lt;&lt;&lt; ${EXAMPLE}\n# {\n#  \"childField\": \"value\"\n# }\n\njq -c '.field' &lt;&lt;&lt; ${EXAMPLE}   # compact output\n# {\"childField\":\"value\"}\n\njq '.field.childField' &lt;&lt;&lt; ${EXAMPLE} \n# \"value\"\n\njq -r '.field.childField' &lt;&lt;&lt; \"${EXAMPLE}\"    # raw output \n#value\n</code></pre>"},{"location":"tools/jq/#arrays","title":"Arrays","text":"<pre><code>API_ENDPOINT=\"https://api.github.com/repos/jqlang/jq/issues?per_page=5\"\nEXAMPLE=$(curl -s $API_ENDPOINT)\n</code></pre> <pre><code>jq '.[]' &lt;&lt;&lt; \"${EXAMPLE}\"           # all elements\njq '.[].url' &lt;&lt;&lt; \"${EXAMPLE}\"       # list with the attribute `url` from the elements \njq '.[1]' &lt;&lt;&lt; \"${EXAMPLE}\"          # one element\njq '.[2:]' &lt;&lt;&lt; \"${EXAMPLE}\"         # from element 2 to the end\njq '.[2:4]' &lt;&lt;&lt; \"${EXAMPLE}\"        # from element 2 to the 4\n</code></pre>"},{"location":"tools/jq/#construct-json-arrays","title":"Construct JSON arrays","text":"<p>Wrapping the filter in <code>[</code> and <code>]</code> generates a valid json output</p> <pre><code>jq '[.[].url]' &lt;&lt;&lt; \"${EXAMPLE}\"    # Creates an array with all the `url` values\n</code></pre>"},{"location":"tools/jq/#object-constructors","title":"Object constructors","text":"<pre><code>jq '[.[] | {number, url}]' &lt;&lt;&lt; \"${EXAMPLE}\"    # extract the `number` and `url` fields from the original objects and wrap it in an array\n</code></pre>"},{"location":"tools/jq/#functions","title":"Functions","text":"<p>https://jqlang.github.io/jq/manual/#builtin-operators-and-functions</p>"},{"location":"tools/jq/#sort","title":"Sort","text":"<pre><code>jq 'sort' &lt;&lt;&lt; \"[1,3,4,2]\"\njq 'sort_by(.title)' &lt;&lt;&lt; \"${EXAMPLE}\"\n</code></pre>"},{"location":"tools/jq/#count","title":"Count","text":"<pre><code>jq 'length' &lt;&lt;&lt; \"${EXAMPLE}\"\n</code></pre>"},{"location":"tools/jq/#map","title":"Map","text":"<p>Notice 1-2-1 mapped attributes don't need the <code>.</code>, but it's required for applying functions</p> <pre><code>jq 'map({url, number, titleLength: .title | length})' &lt;&lt;&lt; \"${EXAMPLE}\" \n</code></pre>"},{"location":"tools/jq/#select","title":"Select","text":"<p>Expects a predicate</p> <pre><code>jq 'map({url, number, titleLength: .title | length}) | map(select(.titleLength&gt;50))' &lt;&lt;&lt; \"${EXAMPLE}\" \n</code></pre>"},{"location":"tools/jq/#keys","title":"Keys","text":""},{"location":"tools/jq/#contains","title":"Contains","text":""},{"location":"tools/jq/#test","title":"Test","text":""},{"location":"tools/jq/#group-by","title":"Group by","text":""},{"location":"tools/jq/#tricks","title":"Tricks","text":"<p>Instant schema</p> <pre><code> jq -r 'path(..) | map(tostring) | join(\"/\")' &lt;&lt;&lt; \"${EXAMPLE}\"  \n</code></pre>"},{"location":"tools/testMermaid/","title":"Mermaid","text":"<pre><code>flowchart TD\n    Start --&gt; Stop</code></pre>"},{"location":"tools/vim/","title":"Vim","text":""},{"location":"tools/vim/#navigate","title":"Navigate","text":"<ul> <li><code>shift</code> +  <code>o</code>    - Go to the end of the file</li> <li><code>:1</code>              - Go to the beginning of the file (line 1)</li> </ul>"},{"location":"tools/vim/#delete","title":"Delete","text":"<ul> <li><code>cc</code>  - Delete current line and switch to insert mode</li> <li><code>dd</code>  - Full line</li> <li><code>D</code>   - Delete to the end of the line</li> <li><code>C</code>   - Delete to the end of te line and switch to insert mode</li> </ul>"},{"location":"tools/vim/#lines","title":"Lines","text":"<ul> <li><code>:X</code>          - Go to line X</li> <li><code>:set number</code> - Show number lines</li> <li><code>:m+X</code>        - Moves line X lines above or down depending on -X of +X</li> </ul>"},{"location":"tools/vim/#visual-mode","title":"Visual mode","text":"<ul> <li><code>ctrl</code> + <code>v</code>  - Starts block selection</li> <li><code>I</code>           - Insert in all selected lines. esc for finishing</li> <li><code>esc</code>         - end visual mode and apply</li> </ul>"},{"location":"tools/vim/#view","title":"View","text":"<ul> <li><code>ctrl</code> + <code>w</code> +                     - Move the focus between views. <code>j</code>, <code>k</code>, <code>l</code> or <code>i</code> can be used instead of   arrows <li><code>vim -o $FILE_ONE $FILE_TWO $FILE_N</code>      - Open multiple files in split mode</li>"},{"location":"tools/vim/#open-terminal","title":"Open terminal","text":"<ul> <li><code>:term</code>           - Split the view and opens the terminal. Other <code>vim</code> instance can be open in that new term</li> </ul>"},{"location":"tools/vim/#yaml-tricks","title":"yaml tricks","text":""},{"location":"tools/vim/#yaml-setup","title":"yaml setup","text":"<p>The default configuration can be saved the <code>~/.vimrc</code>.</p> <p>These are useful for yaml:</p> <ul> <li><code>tabstop</code>     tab press spacing size</li> <li><code>expandtab</code>   make sure to use spaces for tabs.</li> <li><code>shiftwidth</code>  new line extra space when new nested block is detected</li> </ul> <pre><code>set tabstop=2\nset expandtab\nset shiftwidth=2\n</code></pre>"},{"location":"tools/vim/#show-cursor-markers","title":"Show cursor markers","text":"<ul> <li><code>:set cursorcolumn</code>         - Renders a vertical line over the cursor position. Alias <code>:set cuc</code></li> <li><code>:set cursorline</code>           - Renders a horizontal line over the cursor position. Alias <code>:set cul</code></li> <li><code>:set nocursorcolumn</code>       - Removes vertical indicator. Alias <code>:set nocuc</code></li> <li><code>:set nocursorline</code>         - Removes horizontal indicator. Alias <code>:set nocul</code></li> </ul>"}]}